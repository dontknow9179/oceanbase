result_format: 4
explain_protocol: 2
DROP DATABASE IF EXISTS DB_PREDICATE_DEDUCE;
CREATE DATABASE DB_PREDICATE_DEDUCE;
USE DB_PREDICATE_DEDUCE;

create table t1(c1 int, c2 int);
create table t2(c1 int , c2 int, c3 int, c4 int);
create table t3(c1 bigint, c2 varchar(64), c3 datetime);
create table is_t1(c1 int);
create table is_t2(c1 int, c2 int);
create table is_t3(c1 bigint, c2 varchar(64), c3 datetime);

insert/*trace*/into t3 values(20101010000000, '020101010000000', '2010-10-10 00:00:00');
insert/*trace*/into t1 values(NULL, NULL);
insert/*trace*/into t2 values(NULL, NULL, NULL, NULL);

= basic test =

== basic compare: case 1
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 = 2;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 = a.c2], [a.c1 = 2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 = 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 = a.c2 and a.c1 = 2;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([2 = a.c2], [a.c1 = 2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select * from t1 a where a.c1 = a.c2 and a.c1 = 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set c1 = c2 + 1  where a.c1 = a.c2 and a.c1 = 2;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |34  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(cast(2, INT(11, 0)) + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([2 = a.c2], [a.c1 = 2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

update t1 a set c1 = c2 + 1  where a.c1 = a.c2 and a.c1 = 2;
EXPLAIN delete from t1 a where a.c1 = a.c2 and a.c1 = 2;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |1        |14  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([2 = a.c2], [a.c1 = 2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

delete from t1 a where a.c1 = a.c2 and a.c1 = 2;
EXPLAIN insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 = 2;
Query Plan
=================================================
|ID|OPERATOR     |NAME           |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT       |               |1        |15  |
|1 | SUBPLAN SCAN|ANONYMOUS_VIEW1|1        |2   |
|2 |  TABLE SCAN |a              |1        |2   |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=256, 
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([2 = a.c2], [a.c1 = 2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 = 2;
rollback;


== basic compare: case 2
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 > 2;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 > 2], [a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 > 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 = a.c2 and a.c1 > 2;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 > 2], [a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select * from t1 a where a.c1 = a.c2 and a.c1 > 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 > 2;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |27  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 > 2], [a.c1 = a.c2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 > 2;
EXPLAIN delete from t1 a where a.c1 = a.c2 and a.c1 > 2;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |1        |9   |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 > 2], [a.c1 = a.c2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

delete from t1 a where a.c1 = a.c2 and a.c1 > 2;
EXPLAIN insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 > 2;
Query Plan
=================================================
|ID|OPERATOR     |NAME           |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT       |               |1        |9   |
|1 | SUBPLAN SCAN|ANONYMOUS_VIEW1|1        |2   |
|2 |  TABLE SCAN |a              |1        |2   |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=256, 
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([a.c1 > 2], [a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 > 2;
rollback;


== basic compare: case 3
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 >= 2;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 >= 2], [a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 >= 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 = a.c2 and a.c1 >= 2;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 >= 2], [a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select * from t1 a where a.c1 = a.c2 and a.c1 >= 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 >= 2;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |27  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 >= 2], [a.c1 = a.c2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 >= 2;
EXPLAIN delete from t1 a where a.c1 = a.c2 and a.c1 >= 2;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |1        |9   |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 >= 2], [a.c1 = a.c2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

delete from t1 a where a.c1 = a.c2 and a.c1 >= 2;
EXPLAIN insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 >= 2;
Query Plan
=================================================
|ID|OPERATOR     |NAME           |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT       |               |1        |9   |
|1 | SUBPLAN SCAN|ANONYMOUS_VIEW1|1        |2   |
|2 |  TABLE SCAN |a              |1        |2   |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=256, 
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([a.c1 >= 2], [a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 >= 2;
rollback;


== basic compare: case 4
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 < 2;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 < 2], [a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 < 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 = a.c2 and a.c1 < 2;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c2 < 2], [a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select * from t1 a where a.c1 = a.c2 and a.c1 < 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 < 2;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |27  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c2 < 2], [a.c1 = a.c2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 < 2;
EXPLAIN delete from t1 a where a.c1 = a.c2 and a.c1 < 2;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |1        |9   |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c2 < 2], [a.c1 = a.c2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

delete from t1 a where a.c1 = a.c2 and a.c1 < 2;
EXPLAIN insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 < 2;
Query Plan
=================================================
|ID|OPERATOR     |NAME           |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT       |               |1        |9   |
|1 | SUBPLAN SCAN|ANONYMOUS_VIEW1|1        |2   |
|2 |  TABLE SCAN |a              |1        |2   |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=256, 
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([a.c2 < 2], [a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 < 2;
rollback;


== basic compare: case 5
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 <= 2;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 <= 2], [a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 <= 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 = a.c2 and a.c1 <= 2;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c2 <= 2], [a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select * from t1 a where a.c1 = a.c2 and a.c1 <= 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 <= 2;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |27  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c2 <= 2], [a.c1 = a.c2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 <= 2;
EXPLAIN delete from t1 a where a.c1 = a.c2 and a.c1 <= 2;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |1        |9   |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c2 <= 2], [a.c1 = a.c2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

delete from t1 a where a.c1 = a.c2 and a.c1 <= 2;
EXPLAIN insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 <= 2;
Query Plan
=================================================
|ID|OPERATOR     |NAME           |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT       |               |1        |9   |
|1 | SUBPLAN SCAN|ANONYMOUS_VIEW1|1        |2   |
|2 |  TABLE SCAN |a              |1        |2   |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=256, 
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([a.c2 <= 2], [a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 <= 2;
rollback;


== basic compare: case 6
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 like '2%';
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([(T_OP_LIKE, cast(a.c1, VARCHAR(1048576)), '2%', '\\')], [a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 like '2%';
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 = a.c2 and a.c1 like '2%';
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([(T_OP_LIKE, cast(a.c1, VARCHAR(1048576)), '2%', '\\')], [a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select * from t1 a where a.c1 = a.c2 and a.c1 like '2%';
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 like '2%';
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |29  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([(T_OP_LIKE, cast(a.c1, VARCHAR(1048576)), '2%', '\\')], [a.c1 = a.c2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 like '2%';
EXPLAIN delete from t1 a where a.c1 = a.c2 and a.c1 like '2%';
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |1        |10  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([(T_OP_LIKE, cast(a.c1, VARCHAR(1048576)), '2%', '\\')], [a.c1 = a.c2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

delete from t1 a where a.c1 = a.c2 and a.c1 like '2%';
EXPLAIN insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 like '2%';
Query Plan
=================================================
|ID|OPERATOR     |NAME           |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT       |               |1        |11  |
|1 | SUBPLAN SCAN|ANONYMOUS_VIEW1|1        |2   |
|2 |  TABLE SCAN |a              |1        |2   |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=256, 
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([(T_OP_LIKE, cast(a.c1, VARCHAR(1048576)), '2%', '\\')], [a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 like '2%';
rollback;


== basic compare: case 7
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 between 2 and 3;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 >= 2], [a.c1 <= 3], [a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 between 2 and 3;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 = a.c2 and a.c1 between 2 and 3;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 >= 2], [a.c2 <= 3], [a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select * from t1 a where a.c1 = a.c2 and a.c1 between 2 and 3;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 between 2 and 3;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |26  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 >= 2], [a.c2 <= 3], [a.c1 = a.c2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 between 2 and 3;
EXPLAIN delete from t1 a where a.c1 = a.c2 and a.c1 between 2 and 3;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |1        |9   |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 >= 2], [a.c2 <= 3], [a.c1 = a.c2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

delete from t1 a where a.c1 = a.c2 and a.c1 between 2 and 3;
EXPLAIN insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 between 2 and 3;
Query Plan
=================================================
|ID|OPERATOR     |NAME           |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT       |               |1        |9   |
|1 | SUBPLAN SCAN|ANONYMOUS_VIEW1|1        |2   |
|2 |  TABLE SCAN |a              |1        |2   |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=256, 
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([a.c1 >= 2], [a.c2 <= 3], [a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 between 2 and 3;
rollback;


== basic compare: case 7
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 in (2, 3);
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 = a.c2], [a.c1 IN (2, 3)]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 in (2, 3);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 = a.c2 and a.c1 in (2, 3);
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 = a.c2], [a.c1 IN (2, 3)], [a.c2 IN (2, 3)]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select * from t1 a where a.c1 = a.c2 and a.c1 in (2, 3);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 in (2, 3);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |34  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = a.c2], [a.c1 IN (2, 3)], [a.c2 IN (2, 3)]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 in (2, 3);
EXPLAIN delete from t1 a where a.c1 = a.c2 and a.c1 in (2, 3);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |1        |14  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = a.c2], [a.c1 IN (2, 3)], [a.c2 IN (2, 3)]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

delete from t1 a where a.c1 = a.c2 and a.c1 in (2, 3);
EXPLAIN insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 in (2, 3);
Query Plan
=================================================
|ID|OPERATOR     |NAME           |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT       |               |1        |15  |
|1 | SUBPLAN SCAN|ANONYMOUS_VIEW1|1        |2   |
|2 |  TABLE SCAN |a              |1        |2   |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=256, 
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([a.c1 = a.c2], [a.c1 IN (2, 3)], [a.c2 IN (2, 3)]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 in (2, 3);
rollback;

************************** deduce on function *******************************

== deduce on function: case 1
EXPLAIN select /*+no_rewrite*/* from t1 a where round(a.c1) = round(a.c2) and round(a.c1) = 1;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([round(cast(a.c1, BIGINT(-1, 0))) = round(cast(a.c2, BIGINT(-1, 0)))], [round(cast(a.c1, BIGINT(-1, 0))) = 1]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select /*+no_rewrite*/* from t1 a where round(a.c1) = round(a.c2) and round(a.c1) = 1;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where round(a.c1) = round(a.c2) and round(a.c1) = 1;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([round(cast(a.c1, BIGINT(-1, 0))) = 1], [round(cast(a.c2, BIGINT(-1, 0))) = 1]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select * from t1 a where round(a.c1) = round(a.c2) and round(a.c1) = 1;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where round(a.c1) = round(a.c2) and round(a.c1) = 1;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |26  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([round(cast(a.c1, BIGINT(-1, 0))) = 1], [round(cast(a.c2, BIGINT(-1, 0))) = 1]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

update t1 a set a.c1 = a.c2 + 1 where round(a.c1) = round(a.c2) and round(a.c1) = 1;
EXPLAIN delete from t1 a where round(a.c1) = round(a.c2) and round(a.c1) = 1;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |1        |9   |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([round(cast(a.c1, BIGINT(-1, 0))) = 1], [round(cast(a.c2, BIGINT(-1, 0))) = 1]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

delete from t1 a where round(a.c1) = round(a.c2) and round(a.c1) = 1;
EXPLAIN insert into is_t2 select * from t1 a where round(a.c1) = round(a.c2) and round(a.c1) = 1;
Query Plan
=================================================
|ID|OPERATOR     |NAME           |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT       |               |1        |9   |
|1 | SUBPLAN SCAN|ANONYMOUS_VIEW1|1        |2   |
|2 |  TABLE SCAN |a              |1        |2   |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=256, 
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([round(cast(a.c1, BIGINT(-1, 0))) = 1], [round(cast(a.c2, BIGINT(-1, 0))) = 1]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

insert into is_t2 select * from t1 a where round(a.c1) = round(a.c2) and round(a.c1) = 1;
rollback;


== deduce on function: case 2
EXPLAIN select /*+no_rewrite*/* from t1 a where round(a.c1) = a.c2 and round(a.c1) = 1;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([round(cast(a.c1, BIGINT(-1, 0))) = 1], [round(cast(a.c1, BIGINT(-1, 0))) = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select /*+no_rewrite*/* from t1 a where round(a.c1) = a.c2 and round(a.c1) = 1;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where round(a.c1) = a.c2 and round(a.c1) = 1;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([round(cast(a.c1, BIGINT(-1, 0))) = 1], [a.c2 = 1]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select * from t1 a where round(a.c1) = a.c2 and round(a.c1) = 1;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where round(a.c1) = a.c2 and round(a.c1) = 1;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |26  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(cast(1, INT(11, 0)) + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([round(cast(a.c1, BIGINT(-1, 0))) = 1], [a.c2 = 1]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

update t1 a set a.c1 = a.c2 + 1 where round(a.c1) = a.c2 and round(a.c1) = 1;
EXPLAIN delete from t1 a where round(a.c1) = a.c2 and round(a.c1) = 1;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |1        |9   |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([round(cast(a.c1, BIGINT(-1, 0))) = 1], [a.c2 = 1]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

delete from t1 a where round(a.c1) = a.c2 and round(a.c1) = 1;
EXPLAIN insert into is_t2 select * from t1 a where round(a.c1) = a.c2 and round(a.c1) = 1;
Query Plan
=================================================
|ID|OPERATOR     |NAME           |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT       |               |1        |9   |
|1 | SUBPLAN SCAN|ANONYMOUS_VIEW1|1        |2   |
|2 |  TABLE SCAN |a              |1        |2   |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=256, 
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([round(cast(a.c1, BIGINT(-1, 0))) = 1], [a.c2 = 1]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

insert into is_t2 select * from t1 a where round(a.c1) = a.c2 and round(a.c1) = 1;
rollback;

***************************** subquery *********************************

== subquery:case 1
EXPLAIN select /*+no_rewrite*/* from t1 a where exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |4   |
|1 | TABLE SCAN   |a   |1        |2   |
|2 | TABLE SCAN   |b   |1        |2   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([(T_OP_EXISTS, subquery(1))]), rowset=256, 
      exec_params_([a.c1 = 1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)
  2 - output([1]), filter([b.c1 = 1]), startup_filter([?]), rowset=256, 
      access([b.c1]), partitions(p0)

select /*+no_rewrite*/* from t1 a where exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|     |1        |4   |
|1 | TABLE SCAN               |a    |1        |2   |
|2 | MATERIAL                 |     |1        |2   |
|3 |  SUBPLAN SCAN            |VIEW1|1        |2   |
|4 |   TABLE SCAN             |b    |1        |2   |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      conds(nil), nl_params_(nil)
  1 - output([a.c1], [a.c2]), filter([a.c1 = 1]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)
  2 - output(nil), filter(nil), rowset=256
  3 - output(nil), filter(nil), rowset=256, 
      access(nil)
  4 - output([1]), filter([b.c1 = 1]), rowset=256, 
      access([b.c1]), partitions(p0), 
      limit(1), offset(nil)

select * from t1 a where exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
Query Plan
=====================================================
|ID|OPERATOR                   |NAME |EST. ROWS|COST|
-----------------------------------------------------
|0 |UPDATE                     |     |1        |36  |
|1 | NESTED-LOOP JOIN CARTESIAN|     |1        |4   |
|2 |  TABLE SCAN               |a    |1        |2   |
|3 |  MATERIAL                 |     |1        |2   |
|4 |   SUBPLAN SCAN            |VIEW1|1        |2   |
|5 |    TABLE SCAN             |b    |1        |2   |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)}), hash_distinct}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=256, 
      conds(nil), nl_params_(nil)
  2 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = 1]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
  3 - output(nil), filter(nil), rowset=256
  4 - output(nil), filter(nil), rowset=256, 
      access(nil)
  5 - output([1]), filter([b.c1 = 1]), rowset=256, 
      access([b.c1]), partitions(p0), 
      limit(1), offset(nil)

update t1 a set a.c1 = a.c2 + 1 where exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
EXPLAIN delete from t1 a where exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
Query Plan
=====================================================
|ID|OPERATOR                   |NAME |EST. ROWS|COST|
-----------------------------------------------------
|0 |DELETE                     |     |1        |16  |
|1 | NESTED-LOOP JOIN CARTESIAN|     |1        |4   |
|2 |  TABLE SCAN               |a    |1        |2   |
|3 |  MATERIAL                 |     |1        |2   |
|4 |   SUBPLAN SCAN            |VIEW1|1        |2   |
|5 |    TABLE SCAN             |b    |1        |2   |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)}), hash_distinct}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=256, 
      conds(nil), nl_params_(nil)
  2 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = 1]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
  3 - output(nil), filter(nil), rowset=256
  4 - output(nil), filter(nil), rowset=256, 
      access(nil)
  5 - output([1]), filter([b.c1 = 1]), rowset=256, 
      access([b.c1]), partitions(p0), 
      limit(1), offset(nil)

delete from t1 a where exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
EXPLAIN insert into is_t2 select * from t1 a where exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
Query Plan
================================================================
|ID|OPERATOR                    |NAME           |EST. ROWS|COST|
----------------------------------------------------------------
|0 |INSERT                      |               |1        |17  |
|1 | SUBPLAN SCAN               |ANONYMOUS_VIEW1|1        |4   |
|2 |  NESTED-LOOP JOIN CARTESIAN|               |1        |4   |
|3 |   TABLE SCAN               |a              |1        |2   |
|4 |   MATERIAL                 |               |1        |2   |
|5 |    SUBPLAN SCAN            |VIEW1          |1        |2   |
|6 |     TABLE SCAN             |b              |1        |2   |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=256, 
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      conds(nil), nl_params_(nil)
  3 - output([a.c1], [a.c2]), filter([a.c1 = 1]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)
  4 - output(nil), filter(nil), rowset=256
  5 - output(nil), filter(nil), rowset=256, 
      access(nil)
  6 - output([1]), filter([b.c1 = 1]), rowset=256, 
      access([b.c1]), partitions(p0), 
      limit(1), offset(nil)

insert into is_t2 select * from t1 a where exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
rollback;


== subquery:case 2
EXPLAIN select /*+no_rewrite*/* from t1 a where exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |4   |
|1 | TABLE SCAN   |a   |1        |2   |
|2 | TABLE SCAN   |b   |1        |2   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([(T_OP_EXISTS, subquery(1))]), rowset=256, 
      exec_params_([a.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([a.c1], [a.c2]), filter([a.c1 = 2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)
  2 - output([1]), filter([? = b.c1]), rowset=256, 
      access([b.c1]), partitions(p0)

select /*+no_rewrite*/* from t1 a where exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |4   |
|1 | TABLE SCAN   |a   |1        |2   |
|2 | TABLE SCAN   |b   |1        |2   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([a.c1], [a.c2]), filter([a.c1 = 2]), startup_filter([?]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)
  2 - output([1]), filter([2 = b.c1]), rowset=256, 
      access([b.c1]), partitions(p0), 
      limit(1), offset(nil)

select * from t1 a where exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |UPDATE         |    |1        |36  |
|1 | SUBPLAN FILTER|    |1        |4   |
|2 |  TABLE SCAN   |a   |1        |2   |
|3 |  TABLE SCAN   |b   |1        |2   |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=256, 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  2 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = 2]), startup_filter([?]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
  3 - output([1]), filter([2 = b.c1]), rowset=256, 
      access([b.c1]), partitions(p0), 
      limit(1), offset(nil)

update t1 a set a.c1 = a.c2 + 1 where exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
EXPLAIN delete from t1 a where exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |DELETE         |    |1        |16  |
|1 | SUBPLAN FILTER|    |1        |4   |
|2 |  TABLE SCAN   |a   |1        |2   |
|3 |  TABLE SCAN   |b   |1        |2   |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=256, 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  2 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = 2]), startup_filter([?]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
  3 - output([1]), filter([2 = b.c1]), rowset=256, 
      access([b.c1]), partitions(p0), 
      limit(1), offset(nil)

delete from t1 a where exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
EXPLAIN insert into is_t2 select * from t1 a where exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
Query Plan
====================================================
|ID|OPERATOR        |NAME           |EST. ROWS|COST|
----------------------------------------------------
|0 |INSERT          |               |1        |17  |
|1 | SUBPLAN SCAN   |ANONYMOUS_VIEW1|1        |4   |
|2 |  SUBPLAN FILTER|               |1        |4   |
|3 |   TABLE SCAN   |a              |1        |2   |
|4 |   TABLE SCAN   |b              |1        |2   |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=256, 
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      exec_params_(nil), onetime_exprs_([(T_OP_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  3 - output([a.c1], [a.c2]), filter([a.c1 = 2]), startup_filter([?]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)
  4 - output([1]), filter([2 = b.c1]), rowset=256, 
      access([b.c1]), partitions(p0), 
      limit(1), offset(nil)

insert into is_t2 select * from t1 a where exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
rollback;


== subquery:case 3
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 in (select c1 from t2 b where b.c1 = 2);
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |4   |
|1 | TABLE SCAN   |a   |1        |2   |
|2 | TABLE SCAN   |b   |1        |2   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 = ANY(subquery(1))]), rowset=256, 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)
  2 - output([b.c1]), filter([b.c1 = 2]), rowset=256, 
      access([b.c1]), partitions(p0)

select /*+no_rewrite*/* from t1 a where a.c1 in (select c1 from t2 b where b.c1 = 2);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 in (select c1 from t2 b where b.c1 = 2);
Query Plan
====================================================
|ID|OPERATOR                  |NAME |EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN|     |1        |4   |
|1 | TABLE SCAN               |a    |1        |2   |
|2 | MATERIAL                 |     |1        |2   |
|3 |  SUBPLAN SCAN            |VIEW1|1        |2   |
|4 |   TABLE SCAN             |b    |1        |2   |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      conds(nil), nl_params_(nil)
  1 - output([a.c1], [a.c2]), filter([a.c1 = 2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)
  2 - output(nil), filter(nil), rowset=256
  3 - output(nil), filter(nil), rowset=256, 
      access(nil)
  4 - output([1]), filter([b.c1 = 2]), rowset=256, 
      access([b.c1]), partitions(p0), 
      limit(1), offset(nil)

select * from t1 a where a.c1 in (select c1 from t2 b where b.c1 = 2);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 in (select c1 from t2 b where b.c1 = 2);
Query Plan
=====================================================
|ID|OPERATOR                   |NAME |EST. ROWS|COST|
-----------------------------------------------------
|0 |UPDATE                     |     |1        |36  |
|1 | NESTED-LOOP JOIN CARTESIAN|     |1        |4   |
|2 |  TABLE SCAN               |a    |1        |2   |
|3 |  MATERIAL                 |     |1        |2   |
|4 |   SUBPLAN SCAN            |VIEW1|1        |2   |
|5 |    TABLE SCAN             |b    |1        |2   |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)}), hash_distinct}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=256, 
      conds(nil), nl_params_(nil)
  2 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = 2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
  3 - output(nil), filter(nil), rowset=256
  4 - output(nil), filter(nil), rowset=256, 
      access(nil)
  5 - output([1]), filter([b.c1 = 2]), rowset=256, 
      access([b.c1]), partitions(p0), 
      limit(1), offset(nil)

update t1 a set a.c1 = a.c2 + 1 where a.c1 in (select c1 from t2 b where b.c1 = 2);
EXPLAIN delete from t1 a where a.c1 in (select c1 from t2 b where b.c1 = 2);
Query Plan
=====================================================
|ID|OPERATOR                   |NAME |EST. ROWS|COST|
-----------------------------------------------------
|0 |DELETE                     |     |1        |16  |
|1 | NESTED-LOOP JOIN CARTESIAN|     |1        |4   |
|2 |  TABLE SCAN               |a    |1        |2   |
|3 |  MATERIAL                 |     |1        |2   |
|4 |   SUBPLAN SCAN            |VIEW1|1        |2   |
|5 |    TABLE SCAN             |b    |1        |2   |
=====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)}), hash_distinct}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=256, 
      conds(nil), nl_params_(nil)
  2 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = 2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
  3 - output(nil), filter(nil), rowset=256
  4 - output(nil), filter(nil), rowset=256, 
      access(nil)
  5 - output([1]), filter([b.c1 = 2]), rowset=256, 
      access([b.c1]), partitions(p0), 
      limit(1), offset(nil)

delete from t1 a where a.c1 in (select c1 from t2 b where b.c1 = 2);
EXPLAIN insert into is_t2 select * from t1 a where a.c1 in (select c1 from t2 b where b.c1 = 2);
Query Plan
================================================================
|ID|OPERATOR                    |NAME           |EST. ROWS|COST|
----------------------------------------------------------------
|0 |INSERT                      |               |1        |17  |
|1 | SUBPLAN SCAN               |ANONYMOUS_VIEW1|1        |4   |
|2 |  NESTED-LOOP JOIN CARTESIAN|               |1        |4   |
|3 |   TABLE SCAN               |a              |1        |2   |
|4 |   MATERIAL                 |               |1        |2   |
|5 |    SUBPLAN SCAN            |VIEW1          |1        |2   |
|6 |     TABLE SCAN             |b              |1        |2   |
================================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=256, 
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      conds(nil), nl_params_(nil)
  3 - output([a.c1], [a.c2]), filter([a.c1 = 2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)
  4 - output(nil), filter(nil), rowset=256
  5 - output(nil), filter(nil), rowset=256, 
      access(nil)
  6 - output([1]), filter([b.c1 = 2]), rowset=256, 
      access([b.c1]), partitions(p0), 
      limit(1), offset(nil)

insert into is_t2 select * from t1 a where a.c1 in (select c1 from t2 b where b.c1 = 2);
rollback;

***************************** type check *******************************

== type check: case 1
EXPLAIN select /*+no_rewrite*/* from t3 where c1=c2 and c1=cast('2010-10-10 00:00:00' as datetime);
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t3  |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t3.c1], [t3.c2], [t3.c3]), filter([cast(t3.c1, DOUBLE(-1, -1)) = cast(cast('2010-10-10 00:00:00', DATETIME(0, 0)), DOUBLE(-1, -1))], [cast(t3.c1, DECIMAL(20, 0)) = cast(t3.c2, DECIMAL(-1, -1))]), rowset=256,
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

select /*+no_rewrite*/* from t3 where c1=c2 and c1=cast('2010-10-10 00:00:00' as datetime);
+----------------+-----------------+---------------------+
| c1             | c2              | c3                  |
+----------------+-----------------+---------------------+
| 20101010000000 | 020101010000000 | 2010-10-10 00:00:00 |
+----------------+-----------------+---------------------+
EXPLAIN select * from t3 where c1=c2 and c1=cast('2010-10-10 00:00:00' as datetime);
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t3  |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([t3.c1], [t3.c2], [t3.c3]), filter([cast(t3.c1, DOUBLE(-1, -1)) = cast(cast('2010-10-10 00:00:00', DATETIME(0, 0)), DOUBLE(-1, -1))], [cast(t3.c1, DECIMAL(20, 0)) = cast(t3.c2, DECIMAL(-1, -1))]), rowset=256,
      access([t3.c1], [t3.c2], [t3.c3]), partitions(p0)

select * from t3 where c1=c2 and c1=cast('2010-10-10 00:00:00' as datetime);
+----------------+-----------------+---------------------+
| c1             | c2              | c3                  |
+----------------+-----------------+---------------------+
| 20101010000000 | 020101010000000 | 2010-10-10 00:00:00 |
+----------------+-----------------+---------------------+
start transaction;
EXPLAIN update t3 set c1 = 1  where c1=c2 and c1=cast('2010-10-10 00:00:00' as datetime);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |26  |
|1 | TABLE SCAN|t3  |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{t3: ({t3: (t3.__pk_increment, t3.c1, t3.c2, t3.c3)})}]),
      update([t3.c1=column_conv(BIGINT,PS:(20,0),NULL,1)])
  1 - output([t3.__pk_increment], [t3.c1], [t3.c2], [t3.c3]), filter([cast(t3.c1, DOUBLE(-1, -1)) = cast(cast('2010-10-10 00:00:00', DATETIME(0, 0)), DOUBLE(-1, -1))], [cast(t3.c1, DECIMAL(20, 0)) = cast(t3.c2, DECIMAL(-1, -1))]), rowset=256,
      access([t3.__pk_increment], [t3.c1], [t3.c2], [t3.c3]), partitions(p0)

update t3 set c1 = 1  where c1=c2 and c1=cast('2010-10-10 00:00:00' as datetime);
rollback;

****************************** remove redundant predicates *************

== remove redundant predicates: case 1
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 = a.c2;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 = a.c2], [a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 = a.c2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 = a.c2 and a.c1 = a.c2;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select * from t1 a where a.c1 = a.c2 and a.c1 = a.c2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 = a.c2;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |34  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = a.c2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 = a.c2;
EXPLAIN delete from t1 a where a.c1 = a.c2 and a.c1 = a.c2;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |1        |14  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = a.c2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

delete from t1 a where a.c1 = a.c2 and a.c1 = a.c2;
EXPLAIN insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 = a.c2;
Query Plan
=================================================
|ID|OPERATOR     |NAME           |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT       |               |1        |15  |
|1 | SUBPLAN SCAN|ANONYMOUS_VIEW1|1        |2   |
|2 |  TABLE SCAN |a              |1        |2   |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=256, 
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 = a.c2;
rollback;


== remove redundant predicates: case 2
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c2 = a.c1;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 = a.c2], [a.c2 = a.c1]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c2 = a.c1;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 = a.c2 and a.c2 = a.c1;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select * from t1 a where a.c1 = a.c2 and a.c2 = a.c1;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c2 = a.c1;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |34  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = a.c2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c2 = a.c1;
EXPLAIN delete from t1 a where a.c1 = a.c2 and a.c2 = a.c1;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |1        |14  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = a.c2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

delete from t1 a where a.c1 = a.c2 and a.c2 = a.c1;
EXPLAIN insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c2 = a.c1;
Query Plan
=================================================
|ID|OPERATOR     |NAME           |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT       |               |1        |15  |
|1 | SUBPLAN SCAN|ANONYMOUS_VIEW1|1        |2   |
|2 |  TABLE SCAN |a              |1        |2   |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=256, 
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c2 = a.c1;
rollback;


== remove redundant predicates: case 3
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 >= a.c2 and a.c1 >= a.c2;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 >= a.c2], [a.c1 >= a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select /*+no_rewrite*/* from t1 a where a.c1 >= a.c2 and a.c1 >= a.c2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 >= a.c2 and a.c1 >= a.c2;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 >= a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select * from t1 a where a.c1 >= a.c2 and a.c1 >= a.c2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 >= a.c2 and a.c1 >= a.c2;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |29  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 >= a.c2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

update t1 a set a.c1 = a.c2 + 1 where a.c1 >= a.c2 and a.c1 >= a.c2;
EXPLAIN delete from t1 a where a.c1 >= a.c2 and a.c1 >= a.c2;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |1        |10  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 >= a.c2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

delete from t1 a where a.c1 >= a.c2 and a.c1 >= a.c2;
EXPLAIN insert into is_t2 select * from t1 a where a.c1 >= a.c2 and a.c1 >= a.c2;
Query Plan
=================================================
|ID|OPERATOR     |NAME           |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT       |               |1        |11  |
|1 | SUBPLAN SCAN|ANONYMOUS_VIEW1|1        |2   |
|2 |  TABLE SCAN |a              |1        |2   |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=256, 
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([a.c1 >= a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

insert into is_t2 select * from t1 a where a.c1 >= a.c2 and a.c1 >= a.c2;
rollback;


== remove redundant predicates: case 4
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 >= a.c2 and a.c2 <= a.c1;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 >= a.c2], [a.c2 <= a.c1]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select /*+no_rewrite*/* from t1 a where a.c1 >= a.c2 and a.c2 <= a.c1;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 >= a.c2 and a.c2 <= a.c1;
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 >= a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select * from t1 a where a.c1 >= a.c2 and a.c2 <= a.c1;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 >= a.c2 and a.c2 <= a.c1;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |29  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 >= a.c2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

update t1 a set a.c1 = a.c2 + 1 where a.c1 >= a.c2 and a.c2 <= a.c1;
EXPLAIN delete from t1 a where a.c1 >= a.c2 and a.c2 <= a.c1;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |1        |10  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 >= a.c2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

delete from t1 a where a.c1 >= a.c2 and a.c2 <= a.c1;
EXPLAIN insert into is_t2 select * from t1 a where a.c1 >= a.c2 and a.c2 <= a.c1;
Query Plan
=================================================
|ID|OPERATOR     |NAME           |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT       |               |1        |11  |
|1 | SUBPLAN SCAN|ANONYMOUS_VIEW1|1        |2   |
|2 |  TABLE SCAN |a              |1        |2   |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=256, 
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([a.c1 >= a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

insert into is_t2 select * from t1 a where a.c1 >= a.c2 and a.c2 <= a.c1;
rollback;


== remove redundant predicates: case 5
EXPLAIN select /*+no_rewrite*/* from t1 a where (a.c1 between 1 and 2) and (a.c1 between 1 and 2);
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 >= 1], [a.c1 <= 2], [a.c1 >= 1], [a.c1 <= 2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select /*+no_rewrite*/* from t1 a where (a.c1 between 1 and 2) and (a.c1 between 1 and 2);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where (a.c1 between 1 and 2) and (a.c1 between 1 and 2);
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 >= 1], [a.c1 <= 2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select * from t1 a where (a.c1 between 1 and 2) and (a.c1 between 1 and 2);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where (a.c1 between 1 and 2) and (a.c1 between 1 and 2);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |27  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 >= 1], [a.c1 <= 2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

update t1 a set a.c1 = a.c2 + 1 where (a.c1 between 1 and 2) and (a.c1 between 1 and 2);
EXPLAIN delete from t1 a where (a.c1 between 1 and 2) and (a.c1 between 1 and 2);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |1        |9   |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 >= 1], [a.c1 <= 2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

delete from t1 a where (a.c1 between 1 and 2) and (a.c1 between 1 and 2);
EXPLAIN insert into is_t2 select * from t1 a where (a.c1 between 1 and 2) and (a.c1 between 1 and 2);
Query Plan
=================================================
|ID|OPERATOR     |NAME           |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT       |               |1        |9   |
|1 | SUBPLAN SCAN|ANONYMOUS_VIEW1|1        |2   |
|2 |  TABLE SCAN |a              |1        |2   |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=256, 
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([a.c1 >= 1], [a.c1 <= 2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

insert into is_t2 select * from t1 a where (a.c1 between 1 and 2) and (a.c1 between 1 and 2);
rollback;


== remove redundant predicates: case 6
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 in (2, 3) and a.c1 in (2, 3);
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 IN (2, 3)], [a.c1 IN (2, 3)]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select /*+no_rewrite*/* from t1 a where a.c1 in (2, 3) and a.c1 in (2, 3);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 in (2, 3) and a.c1 in (2, 3);
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 IN (2, 3)]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select * from t1 a where a.c1 in (2, 3) and a.c1 in (2, 3);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 in (2, 3) and a.c1 in (2, 3);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |34  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 IN (2, 3)]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

update t1 a set a.c1 = a.c2 + 1 where a.c1 in (2, 3) and a.c1 in (2, 3);
EXPLAIN delete from t1 a where a.c1 in (2, 3) and a.c1 in (2, 3);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |1        |14  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 IN (2, 3)]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

delete from t1 a where a.c1 in (2, 3) and a.c1 in (2, 3);
EXPLAIN insert into is_t2 select * from t1 a where a.c1 in (2, 3) and a.c1 in (2, 3);
Query Plan
=================================================
|ID|OPERATOR     |NAME           |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT       |               |1        |15  |
|1 | SUBPLAN SCAN|ANONYMOUS_VIEW1|1        |2   |
|2 |  TABLE SCAN |a              |1        |2   |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=256, 
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([a.c1 IN (2, 3)]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

insert into is_t2 select * from t1 a where a.c1 in (2, 3) and a.c1 in (2, 3);
rollback;


== remove redundant predicates: case 7
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 not in (2, 3) and a.c1 not in (2, 3);
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([(T_OP_NOT_IN, a.c1, (2, 3))], [(T_OP_NOT_IN, a.c1, (2, 3))]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select /*+no_rewrite*/* from t1 a where a.c1 not in (2, 3) and a.c1 not in (2, 3);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 not in (2, 3) and a.c1 not in (2, 3);
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([(T_OP_NOT_IN, a.c1, (2, 3))]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select * from t1 a where a.c1 not in (2, 3) and a.c1 not in (2, 3);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 not in (2, 3) and a.c1 not in (2, 3);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |30  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([(T_OP_NOT_IN, a.c1, (2, 3))]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

update t1 a set a.c1 = a.c2 + 1 where a.c1 not in (2, 3) and a.c1 not in (2, 3);
EXPLAIN delete from t1 a where a.c1 not in (2, 3) and a.c1 not in (2, 3);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |1        |11  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([(T_OP_NOT_IN, a.c1, (2, 3))]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

delete from t1 a where a.c1 not in (2, 3) and a.c1 not in (2, 3);
EXPLAIN insert into is_t2 select * from t1 a where a.c1 not in (2, 3) and a.c1 not in (2, 3);
Query Plan
=================================================
|ID|OPERATOR     |NAME           |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT       |               |1        |12  |
|1 | SUBPLAN SCAN|ANONYMOUS_VIEW1|1        |2   |
|2 |  TABLE SCAN |a              |1        |2   |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=256, 
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([(T_OP_NOT_IN, a.c1, (2, 3))]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

insert into is_t2 select * from t1 a where a.c1 not in (2, 3) and a.c1 not in (2, 3);
rollback;

************************* can not deduce ******************

== can not deduce: case 1
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 not like '2%';
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([(T_OP_NOT, (T_OP_LIKE, cast(a.c1, VARCHAR(1048576)), '2%', '\\'))], [a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 not like '2%';
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 = a.c2 and a.c1 not like '2%';
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([(T_OP_NOT, (T_OP_LIKE, cast(a.c1, VARCHAR(1048576)), '2%', '\\'))], [a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select * from t1 a where a.c1 = a.c2 and a.c1 not like '2%';
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 not like '2%';
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |31  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([(T_OP_NOT, (T_OP_LIKE, cast(a.c1, VARCHAR(1048576)), '2%', '\\'))], [a.c1 = a.c2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 not like '2%';
EXPLAIN delete from t1 a where a.c1 = a.c2 and a.c1 not like '2%';
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |1        |12  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([(T_OP_NOT, (T_OP_LIKE, cast(a.c1, VARCHAR(1048576)), '2%', '\\'))], [a.c1 = a.c2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

delete from t1 a where a.c1 = a.c2 and a.c1 not like '2%';
EXPLAIN insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 not like '2%';
Query Plan
=================================================
|ID|OPERATOR     |NAME           |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT       |               |1        |13  |
|1 | SUBPLAN SCAN|ANONYMOUS_VIEW1|1        |2   |
|2 |  TABLE SCAN |a              |1        |2   |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=256, 
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([(T_OP_NOT, (T_OP_LIKE, cast(a.c1, VARCHAR(1048576)), '2%', '\\'))], [a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 not like '2%';
rollback;


== can not deduce: case 2
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 not in (2, 3);
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([(T_OP_NOT_IN, a.c1, (2, 3))], [a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select /*+no_rewrite*/* from t1 a where a.c1 = a.c2 and a.c1 not in (2, 3);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 = a.c2 and a.c1 not in (2, 3);
Query Plan
===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|a   |1        |2   |
===================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([(T_OP_NOT_IN, a.c1, (2, 3))], [a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select * from t1 a where a.c1 = a.c2 and a.c1 not in (2, 3);
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 not in (2, 3);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |UPDATE     |    |1        |30  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([(T_OP_NOT_IN, a.c1, (2, 3))], [a.c1 = a.c2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

update t1 a set a.c1 = a.c2 + 1 where a.c1 = a.c2 and a.c1 not in (2, 3);
EXPLAIN delete from t1 a where a.c1 = a.c2 and a.c1 not in (2, 3);
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |DELETE     |    |1        |11  |
|1 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter([(T_OP_NOT_IN, a.c1, (2, 3))], [a.c1 = a.c2]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)

delete from t1 a where a.c1 = a.c2 and a.c1 not in (2, 3);
EXPLAIN insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 not in (2, 3);
Query Plan
=================================================
|ID|OPERATOR     |NAME           |EST. ROWS|COST|
-------------------------------------------------
|0 |INSERT       |               |1        |12  |
|1 | SUBPLAN SCAN|ANONYMOUS_VIEW1|1        |2   |
|2 |  TABLE SCAN |a              |1        |2   |
=================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=256, 
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter([(T_OP_NOT_IN, a.c1, (2, 3))], [a.c1 = a.c2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

insert into is_t2 select * from t1 a where a.c1 = a.c2 and a.c1 not in (2, 3);
rollback;

************************* 不能推导 anti semi join ***************

== 不能推导 anti semi join:case 1
EXPLAIN select /*+no_rewrite*/* from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |4   |
|1 | TABLE SCAN   |a   |1        |2   |
|2 | TABLE SCAN   |b   |1        |2   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))]), rowset=256, 
      exec_params_([a.c1 = 1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)
  2 - output([1]), filter([b.c1 = 1]), startup_filter([?]), rowset=256, 
      access([b.c1]), partitions(p0)

select /*+no_rewrite*/* from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
+------+------+
| c1   | c2   |
+------+------+
| NULL | NULL |
+------+------+
EXPLAIN select * from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
Query Plan
===============================================
|ID|OPERATOR             |NAME |EST. ROWS|COST|
-----------------------------------------------
|0 |NESTED-LOOP ANTI JOIN|     |0        |4   |
|1 | TABLE SCAN          |a    |1        |2   |
|2 | MATERIAL            |     |1        |2   |
|3 |  SUBPLAN SCAN       |VIEW1|1        |2   |
|4 |   TABLE SCAN        |b    |1        |2   |
===============================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      conds([a.c1 = 1]), nl_params_(nil)
  1 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)
  2 - output(nil), filter(nil), rowset=256
  3 - output(nil), filter(nil), rowset=256, 
      access(nil)
  4 - output([1]), filter([b.c1 = 1]), rowset=256, 
      access([b.c1]), partitions(p0), 
      limit(1), offset(nil)

select * from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
+------+------+
| c1   | c2   |
+------+------+
| NULL | NULL |
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where not exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
Query Plan
================================================
|ID|OPERATOR              |NAME |EST. ROWS|COST|
------------------------------------------------
|0 |UPDATE                |     |0        |28  |
|1 | NESTED-LOOP ANTI JOIN|     |0        |4   |
|2 |  TABLE SCAN          |a    |1        |2   |
|3 |  MATERIAL            |     |1        |2   |
|4 |   SUBPLAN SCAN       |VIEW1|1        |2   |
|5 |    TABLE SCAN        |b    |1        |2   |
================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=256, 
      conds([a.c1 = 1]), nl_params_(nil)
  2 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
  3 - output(nil), filter(nil), rowset=256
  4 - output(nil), filter(nil), rowset=256, 
      access(nil)
  5 - output([1]), filter([b.c1 = 1]), rowset=256, 
      access([b.c1]), partitions(p0), 
      limit(1), offset(nil)

update t1 a set a.c1 = a.c2 + 1 where not exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
EXPLAIN delete from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
Query Plan
================================================
|ID|OPERATOR              |NAME |EST. ROWS|COST|
------------------------------------------------
|0 |DELETE                |     |0        |11  |
|1 | NESTED-LOOP ANTI JOIN|     |0        |4   |
|2 |  TABLE SCAN          |a    |1        |2   |
|3 |  MATERIAL            |     |1        |2   |
|4 |   SUBPLAN SCAN       |VIEW1|1        |2   |
|5 |    TABLE SCAN        |b    |1        |2   |
================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=256, 
      conds([a.c1 = 1]), nl_params_(nil)
  2 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
  3 - output(nil), filter(nil), rowset=256
  4 - output(nil), filter(nil), rowset=256, 
      access(nil)
  5 - output([1]), filter([b.c1 = 1]), rowset=256, 
      access([b.c1]), partitions(p0), 
      limit(1), offset(nil)

delete from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
EXPLAIN insert into is_t2 select * from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
Query Plan
===========================================================
|ID|OPERATOR               |NAME           |EST. ROWS|COST|
-----------------------------------------------------------
|0 |INSERT                 |               |0        |11  |
|1 | SUBPLAN SCAN          |ANONYMOUS_VIEW1|0        |4   |
|2 |  NESTED-LOOP ANTI JOIN|               |0        |4   |
|3 |   TABLE SCAN          |a              |1        |2   |
|4 |   MATERIAL            |               |1        |2   |
|5 |    SUBPLAN SCAN       |VIEW1          |1        |2   |
|6 |     TABLE SCAN        |b              |1        |2   |
===========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=256, 
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      conds([a.c1 = 1]), nl_params_(nil)
  3 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)
  4 - output(nil), filter(nil), rowset=256
  5 - output(nil), filter(nil), rowset=256, 
      access(nil)
  6 - output([1]), filter([b.c1 = 1]), rowset=256, 
      access([b.c1]), partitions(p0), 
      limit(1), offset(nil)

insert into is_t2 select * from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1 and b.c1 = 1);
rollback;


== 能推导 anti semi join:case 2
EXPLAIN select /*+no_rewrite*/* from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |4   |
|1 | TABLE SCAN   |a   |1        |2   |
|2 | TABLE SCAN   |b   |1        |2   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([(T_OP_NOT_EXISTS, subquery(1))]), rowset=256, 
      exec_params_([a.c1]), onetime_exprs_(nil), init_plan_idxs_(nil)
  1 - output([a.c1], [a.c2]), filter([a.c1 = 2]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)
  2 - output([1]), filter([? = b.c1]), rowset=256, 
      access([b.c1]), partitions(p0)

select /*+no_rewrite*/* from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |4   |
|1 | TABLE SCAN   |a   |1        |2   |
|2 | TABLE SCAN   |b   |1        |2   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  1 - output([a.c1], [a.c2]), filter([a.c1 = 2]), startup_filter([?]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)
  2 - output([1]), filter([2 = b.c1]), rowset=256, 
      access([b.c1]), partitions(p0), 
      limit(1), offset(nil)

select * from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where not exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |UPDATE         |    |1        |36  |
|1 | SUBPLAN FILTER|    |1        |4   |
|2 |  TABLE SCAN   |a   |1        |2   |
|3 |  TABLE SCAN   |b   |1        |2   |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=256, 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  2 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = 2]), startup_filter([?]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
  3 - output([1]), filter([2 = b.c1]), rowset=256, 
      access([b.c1]), partitions(p0), 
      limit(1), offset(nil)

update t1 a set a.c1 = a.c2 + 1 where not exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
EXPLAIN delete from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
Query Plan
========================================
|ID|OPERATOR       |NAME|EST. ROWS|COST|
----------------------------------------
|0 |DELETE         |    |1        |16  |
|1 | SUBPLAN FILTER|    |1        |4   |
|2 |  TABLE SCAN   |a   |1        |2   |
|3 |  TABLE SCAN   |b   |1        |2   |
========================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=256, 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  2 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = 2]), startup_filter([?]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
  3 - output([1]), filter([2 = b.c1]), rowset=256, 
      access([b.c1]), partitions(p0), 
      limit(1), offset(nil)

delete from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
EXPLAIN insert into is_t2 select * from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
Query Plan
====================================================
|ID|OPERATOR        |NAME           |EST. ROWS|COST|
----------------------------------------------------
|0 |INSERT          |               |1        |17  |
|1 | SUBPLAN SCAN   |ANONYMOUS_VIEW1|1        |4   |
|2 |  SUBPLAN FILTER|               |1        |4   |
|3 |   TABLE SCAN   |a              |1        |2   |
|4 |   TABLE SCAN   |b              |1        |2   |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=256, 
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      exec_params_(nil), onetime_exprs_([(T_OP_NOT_EXISTS, subquery(1))]), init_plan_idxs_(nil)
  3 - output([a.c1], [a.c2]), filter([a.c1 = 2]), startup_filter([?]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)
  4 - output([1]), filter([2 = b.c1]), rowset=256, 
      access([b.c1]), partitions(p0), 
      limit(1), offset(nil)

insert into is_t2 select * from t1 a where not exists (select 1 from t2 b where a.c1 = b.c1) and a.c1 = 2;
rollback;


== 不能推导 anti semi join:case 3
EXPLAIN select /*+no_rewrite*/* from t1 a where a.c1 not in (select c1 from t2 b) and a.c1 = 1;
Query Plan
=======================================
|ID|OPERATOR      |NAME|EST. ROWS|COST|
---------------------------------------
|0 |SUBPLAN FILTER|    |1        |4   |
|1 | TABLE SCAN   |a   |1        |2   |
|2 | TABLE SCAN   |b   |1        |2   |
=======================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter([a.c1 != ALL(subquery(1))]), rowset=256, 
      exec_params_(nil), onetime_exprs_(nil), init_plan_idxs_([1])
  1 - output([a.c1], [a.c2]), filter([a.c1 = 1]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)
  2 - output([b.c1]), filter(nil), rowset=256, 
      access([b.c1]), partitions(p0)

select /*+no_rewrite*/* from t1 a where a.c1 not in (select c1 from t2 b) and a.c1 = 1;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
EXPLAIN select * from t1 a where a.c1 not in (select c1 from t2 b) and a.c1 = 1;
Query Plan
=========================================================
|ID|OPERATOR                       |NAME |EST. ROWS|COST|
---------------------------------------------------------
|0 |NESTED-LOOP ANTI JOIN CARTESIAN|     |0        |4   |
|1 | TABLE SCAN                    |a    |1        |2   |
|2 | MATERIAL                      |     |1        |2   |
|3 |  SUBPLAN SCAN                 |VIEW1|1        |2   |
|4 |   TABLE SCAN                  |b    |1        |2   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      conds(nil), nl_params_(nil)
  1 - output([a.c1], [a.c2]), filter([a.c1 = 1]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)
  2 - output(nil), filter(nil), rowset=256
  3 - output(nil), filter(nil), rowset=256, 
      access(nil)
  4 - output([1]), filter([b.c1 = 1 OR (T_OP_IS, b.c1, NULL, 0)]), rowset=256, 
      access([b.c1]), partitions(p0), 
      limit(1), offset(nil)

select * from t1 a where a.c1 not in (select c1 from t2 b) and a.c1 = 1;
+------+------+
| c1   | c2   |
+------+------+
+------+------+
start transaction;
EXPLAIN update t1 a set a.c1 = a.c2 + 1 where a.c1 not in (select c1 from t2 b) and a.c1 = 1;
Query Plan
==========================================================
|ID|OPERATOR                        |NAME |EST. ROWS|COST|
----------------------------------------------------------
|0 |UPDATE                          |     |0        |28  |
|1 | NESTED-LOOP ANTI JOIN CARTESIAN|     |0        |4   |
|2 |  TABLE SCAN                    |a    |1        |2   |
|3 |  MATERIAL                      |     |1        |2   |
|4 |   SUBPLAN SCAN                 |VIEW1|1        |2   |
|5 |    TABLE SCAN                  |b    |1        |2   |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}]),
      update([a.c1=column_conv(INT,PS:(11,0),NULL,cast(a.c2 + 1, INT(-1, 0)))])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=256, 
      conds(nil), nl_params_(nil)
  2 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = 1]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
  3 - output(nil), filter(nil), rowset=256
  4 - output(nil), filter(nil), rowset=256, 
      access(nil)
  5 - output([1]), filter([b.c1 = 1 OR (T_OP_IS, b.c1, NULL, 0)]), rowset=256, 
      access([b.c1]), partitions(p0), 
      limit(1), offset(nil)

update t1 a set a.c1 = a.c2 + 1 where a.c1 not in (select c1 from t2 b) and a.c1 = 1;
EXPLAIN delete from t1 a where a.c1 not in (select c1 from t2 b) and a.c1 = 1;
Query Plan
==========================================================
|ID|OPERATOR                        |NAME |EST. ROWS|COST|
----------------------------------------------------------
|0 |DELETE                          |     |0        |11  |
|1 | NESTED-LOOP ANTI JOIN CARTESIAN|     |0        |4   |
|2 |  TABLE SCAN                    |a    |1        |2   |
|3 |  MATERIAL                      |     |1        |2   |
|4 |   SUBPLAN SCAN                 |VIEW1|1        |2   |
|5 |    TABLE SCAN                  |b    |1        |2   |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), table_columns([{a: ({t1: (a.__pk_increment, a.c1, a.c2)})}])
  1 - output([a.__pk_increment], [a.c1], [a.c2]), filter(nil), rowset=256, 
      conds(nil), nl_params_(nil)
  2 - output([a.__pk_increment], [a.c1], [a.c2]), filter([a.c1 = 1]), rowset=256, 
      access([a.__pk_increment], [a.c1], [a.c2]), partitions(p0)
  3 - output(nil), filter(nil), rowset=256
  4 - output(nil), filter(nil), rowset=256, 
      access(nil)
  5 - output([1]), filter([b.c1 = 1 OR (T_OP_IS, b.c1, NULL, 0)]), rowset=256, 
      access([b.c1]), partitions(p0), 
      limit(1), offset(nil)

delete from t1 a where a.c1 not in (select c1 from t2 b) and a.c1 = 1;
EXPLAIN insert into is_t2 select * from t1 a where a.c1 not in (select c1 from t2 b) and a.c1 = 1;
Query Plan
=====================================================================
|ID|OPERATOR                         |NAME           |EST. ROWS|COST|
---------------------------------------------------------------------
|0 |INSERT                           |               |0        |11  |
|1 | SUBPLAN SCAN                    |ANONYMOUS_VIEW1|0        |4   |
|2 |  NESTED-LOOP ANTI JOIN CARTESIAN|               |0        |4   |
|3 |   TABLE SCAN                    |a              |1        |2   |
|4 |   MATERIAL                      |               |1        |2   |
|5 |    SUBPLAN SCAN                 |VIEW1          |1        |2   |
|6 |     TABLE SCAN                  |b              |1        |2   |
=====================================================================

Outputs & filters: 
-------------------------------------
  0 - output(nil), filter(nil), 
      columns([{is_t2: ({is_t2: (is_t2.__pk_increment, is_t2.c1, is_t2.c2)})}]), partitions(p0), 
      column_values([T_HIDDEN_PK], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c1)], [column_conv(INT,PS:(11,0),NULL,ANONYMOUS_VIEW1.c2)])
  1 - output([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2]), filter(nil), rowset=256, 
      access([ANONYMOUS_VIEW1.c1], [ANONYMOUS_VIEW1.c2])
  2 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      conds(nil), nl_params_(nil)
  3 - output([a.c1], [a.c2]), filter([a.c1 = 1]), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)
  4 - output(nil), filter(nil), rowset=256
  5 - output(nil), filter(nil), rowset=256, 
      access(nil)
  6 - output([1]), filter([b.c1 = 1 OR (T_OP_IS, b.c1, NULL, 0)]), rowset=256, 
      access([b.c1]), partitions(p0), 
      limit(1), offset(nil)

insert into is_t2 select * from t1 a where a.c1 not in (select c1 from t2 b) and a.c1 = 1;
rollback;

************************* 不能推导 anti semi join ***************

EXPLAIN select /*+ NO_REWRITE */ * from t1 a, t2 b where a.c1 = b.c1 and b.c1 is not null;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |1        |4   |
|1 | TABLE SCAN|a   |1        |2   |
|2 | TABLE SCAN|b   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=256, 
      equal_conds([a.c1 = b.c1]), other_conds(nil)
  1 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)
  2 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter([(T_OP_IS_NOT, b.c1, NULL, 0)]), rowset=256, 
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0)

select /*+ NO_REWRITE */ * from t1 a, t2 b where a.c1 = b.c1 and b.c1 is not null;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c3   | c4   |
+------+------+------+------+------+------+
+------+------+------+------+------+------+
EXPLAIN select * from t1 a, t2 b where a.c1 = b.c1 and b.c1 is not null;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |1        |4   |
|1 | TABLE SCAN|a   |1        |2   |
|2 | TABLE SCAN|b   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=256, 
      equal_conds([a.c1 = b.c1]), other_conds(nil)
  1 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)
  2 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter([(T_OP_IS_NOT, b.c1, NULL, 0)]), rowset=256, 
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0)

select * from t1 a, t2 b where a.c1 = b.c1 and b.c1 is not null;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c3   | c4   |
+------+------+------+------+------+------+
+------+------+------+------+------+------+


EXPLAIN select /*+ NO_REWRITE */ * from t1 a, t2 b where a.c1 = b.c1 and b.c1 is not null;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |1        |4   |
|1 | TABLE SCAN|a   |1        |2   |
|2 | TABLE SCAN|b   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=256, 
      equal_conds([a.c1 = b.c1]), other_conds(nil)
  1 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)
  2 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter([(T_OP_IS_NOT, b.c1, NULL, 0)]), rowset=256, 
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0)

select /*+ NO_REWRITE */ * from t1 a, t2 b where a.c1 = b.c1 and b.c1 is not null;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c3   | c4   |
+------+------+------+------+------+------+
+------+------+------+------+------+------+
EXPLAIN select * from t1 a, t2 b where a.c1 = b.c1 and b.c1 is not null;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |1        |4   |
|1 | TABLE SCAN|a   |1        |2   |
|2 | TABLE SCAN|b   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=256, 
      equal_conds([a.c1 = b.c1]), other_conds(nil)
  1 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)
  2 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter([(T_OP_IS_NOT, b.c1, NULL, 0)]), rowset=256, 
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0)

select * from t1 a, t2 b where a.c1 = b.c1 and b.c1 is not null;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c3   | c4   |
+------+------+------+------+------+------+
+------+------+------+------+------+------+


EXPLAIN select /*+ NO_REWRITE */ * from t1 a, t2 b where a.c1 = b.c1 and b.c1 is null;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |0        |4   |
|1 | TABLE SCAN |b   |0        |2   |
|2 | SORT       |    |1        |2   |
|3 |  TABLE SCAN|a   |1        |2   |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=256, 
      equal_conds([a.c1 = b.c1]), other_conds(nil)
  1 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter([(T_OP_IS, b.c1, NULL, 0)]), rowset=256, 
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0)
  2 - output([a.c1], [a.c2]), filter(nil), rowset=256, sort_keys([a.c1, ASC])
  3 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select /*+ NO_REWRITE */ * from t1 a, t2 b where a.c1 = b.c1 and b.c1 is null;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c3   | c4   |
+------+------+------+------+------+------+
+------+------+------+------+------+------+
EXPLAIN select * from t1 a, t2 b where a.c1 = b.c1 and b.c1 is null;
Query Plan
=====================================
|ID|OPERATOR    |NAME|EST. ROWS|COST|
-------------------------------------
|0 |MERGE JOIN  |    |0        |4   |
|1 | TABLE SCAN |b   |0        |2   |
|2 | SORT       |    |1        |2   |
|3 |  TABLE SCAN|a   |1        |2   |
=====================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=256, 
      equal_conds([a.c1 = b.c1]), other_conds(nil)
  1 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter([(T_OP_IS, b.c1, NULL, 0)]), rowset=256, 
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0)
  2 - output([a.c1], [a.c2]), filter(nil), rowset=256, sort_keys([a.c1, ASC])
  3 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select * from t1 a, t2 b where a.c1 = b.c1 and b.c1 is null;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c3   | c4   |
+------+------+------+------+------+------+
+------+------+------+------+------+------+


EXPLAIN select /*+ NO_REWRITE */ * from t1 a, t2 b where a.c1 = b.c1 and b.c1 <=> null;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |0        |4   |
|1 | TABLE SCAN|b   |0        |2   |
|2 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=256, 
      equal_conds([a.c1 = b.c1]), other_conds(nil)
  1 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter([b.c1 <=> NULL]), rowset=256, 
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0)
  2 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select /*+ NO_REWRITE */ * from t1 a, t2 b where a.c1 = b.c1 and b.c1 <=> null;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c3   | c4   |
+------+------+------+------+------+------+
+------+------+------+------+------+------+
EXPLAIN select * from t1 a, t2 b where a.c1 = b.c1 and b.c1 <=> null;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |0        |4   |
|1 | TABLE SCAN|b   |0        |2   |
|2 | TABLE SCAN|a   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=256, 
      equal_conds([a.c1 = b.c1]), other_conds(nil)
  1 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter([b.c1 <=> NULL]), rowset=256, 
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0)
  2 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)

select * from t1 a, t2 b where a.c1 = b.c1 and b.c1 <=> null;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c3   | c4   |
+------+------+------+------+------+------+
+------+------+------+------+------+------+


EXPLAIN select /*+ NO_REWRITE */ * from t1 a, t2 b where a.c1 = b.c1 and b.c1 <=> 1;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |1        |4   |
|1 | TABLE SCAN|a   |1        |2   |
|2 | TABLE SCAN|b   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=256, 
      equal_conds([a.c1 = b.c1]), other_conds(nil)
  1 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)
  2 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter([b.c1 <=> 1]), rowset=256, 
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0)

select /*+ NO_REWRITE */ * from t1 a, t2 b where a.c1 = b.c1 and b.c1 <=> 1;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c3   | c4   |
+------+------+------+------+------+------+
+------+------+------+------+------+------+
EXPLAIN select * from t1 a, t2 b where a.c1 = b.c1 and b.c1 <=> 1;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |1        |4   |
|1 | TABLE SCAN|a   |1        |2   |
|2 | TABLE SCAN|b   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=256, 
      equal_conds([a.c1 = b.c1]), other_conds(nil)
  1 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)
  2 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter([b.c1 <=> 1]), rowset=256, 
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0)

select * from t1 a, t2 b where a.c1 = b.c1 and b.c1 <=> 1;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c3   | c4   |
+------+------+------+------+------+------+
+------+------+------+------+------+------+


EXPLAIN select /*+ NO_REWRITE */ * from t1 a, t2 b where a.c1 <=> b.c1 and b.c1 <=> 1;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |1        |4   |
|1 | TABLE SCAN|a   |1        |2   |
|2 | TABLE SCAN|b   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=256, 
      equal_conds([a.c1 <=> b.c1]), other_conds(nil)
  1 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)
  2 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter([b.c1 <=> 1]), rowset=256, 
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0)

select /*+ NO_REWRITE */ * from t1 a, t2 b where a.c1 <=> b.c1 and b.c1 <=> 1;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c3   | c4   |
+------+------+------+------+------+------+
+------+------+------+------+------+------+
EXPLAIN select * from t1 a, t2 b where a.c1 <=> b.c1 and b.c1 <=> 1;
Query Plan
====================================
|ID|OPERATOR   |NAME|EST. ROWS|COST|
------------------------------------
|0 |HASH JOIN  |    |1        |4   |
|1 | TABLE SCAN|a   |1        |2   |
|2 | TABLE SCAN|b   |1        |2   |
====================================

Outputs & filters: 
-------------------------------------
  0 - output([a.c1], [a.c2], [b.c1], [b.c2], [b.c3], [b.c4]), filter(nil), rowset=256, 
      equal_conds([a.c1 <=> b.c1]), other_conds(nil)
  1 - output([a.c1], [a.c2]), filter(nil), rowset=256, 
      access([a.c1], [a.c2]), partitions(p0)
  2 - output([b.c1], [b.c2], [b.c3], [b.c4]), filter([b.c1 <=> 1]), rowset=256, 
      access([b.c1], [b.c2], [b.c3], [b.c4]), partitions(p0)

select * from t1 a, t2 b where a.c1 <=> b.c1 and b.c1 <=> 1;
+------+------+------+------+------+------+
| c1   | c2   | c1   | c2   | c3   | c4   |
+------+------+------+------+------+------+
+------+------+------+------+------+------+

####### outer join 谓词推导测试 #######
drop table if exists tt1, tt2, tt3;
create table tt1 (c1 int primary key, c2 varchar(10));
create table tt2 (c1 int primary key, c2 varchar(10));
create table tt3 (c1 int primary key, c2 varchar(10));

## tt1 left join tt2
EXPLAIN select /*+use_merge(tt1 tt2)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 where tt1.c1 = 1;
Query Plan
=========================================================
|ID|OPERATOR                        |NAME|EST. ROWS|COST|
---------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN CARTESIAN|    |1        |6   |
|1 | TABLE GET                      |tt1 |1        |3   |
|2 | TABLE GET                      |tt2 |1        |3   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2]), filter(nil), rowset=256, 
      conds(nil), nl_params_(nil)
  1 - output([tt1.c1], [tt1.c2]), filter(nil), rowset=256, 
      access([tt1.c1], [tt1.c2]), partitions(p0)
  2 - output([tt2.c1], [tt2.c2]), filter(nil), rowset=256, 
      access([tt2.c1], [tt2.c2]), partitions(p0)

select /*+use_merge(tt1 tt2)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 where tt1.c1 = 1;
+----+------+----+------+
| c1 | c2   | c1 | c2   |
+----+------+----+------+
|  1 | a1   | NULL | NULL |
+----+------+----+------+
EXPLAIN select /*+no_rewrite, use_merge(tt1 tt2)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 where tt1.c1 = 1;
Query Plan
=========================================
|ID|OPERATOR        |NAME|EST. ROWS|COST|
-----------------------------------------
|0 |MERGE OUTER JOIN|    |1        |5   |
|1 | TABLE GET      |tt1 |1        |3   |
|2 | TABLE SCAN     |tt2 |2        |2   |
=========================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2]), filter(nil), rowset=256, 
      equal_conds([tt1.c1 = tt2.c1]), other_conds(nil)
  1 - output([tt1.c1], [tt1.c2]), filter(nil), rowset=256, 
      access([tt1.c1], [tt1.c2]), partitions(p0)
  2 - output([tt2.c1], [tt2.c2]), filter(nil), rowset=256, 
      access([tt2.c1], [tt2.c2]), partitions(p0)

select /*+no_rewrite, use_merge(tt1 tt2)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 where tt1.c1 = 1;
+----+------+----+------+
| c1 | c2   | c1 | c2   |
+----+------+----+------+
|  1 | a1   | NULL | NULL |
+----+------+----+------+

## tt1 left join tt2 left join tt3
EXPLAIN select /*+use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 left join tt3 on tt1.c1 = tt3.c1 where tt1.c1 = 1;
Query Plan
==========================================================
|ID|OPERATOR                         |NAME|EST. ROWS|COST|
----------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN CARTESIAN |    |1        |9   |
|1 | NESTED-LOOP OUTER JOIN CARTESIAN|    |1        |6   |
|2 |  TABLE GET                      |tt1 |1        |3   |
|3 |  TABLE GET                      |tt2 |1        |3   |
|4 | TABLE GET                       |tt3 |1        |3   |
==========================================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2], [tt3.c1], [tt3.c2]), filter(nil), rowset=256, 
      conds(nil), nl_params_(nil)
  1 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2]), filter(nil), rowset=256, 
      conds(nil), nl_params_(nil)
  2 - output([tt1.c1], [tt1.c2]), filter(nil), rowset=256, 
      access([tt1.c1], [tt1.c2]), partitions(p0)
  3 - output([tt2.c1], [tt2.c2]), filter(nil), rowset=256, 
      access([tt2.c1], [tt2.c2]), partitions(p0)
  4 - output([tt3.c1], [tt3.c2]), filter(nil), rowset=256, 
      access([tt3.c1], [tt3.c2]), partitions(p0)

select /*+use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 left join tt3 on tt1.c1 = tt3.c1 where tt1.c1 = 1;
+----+------+----+------+----+------+
| c1 | c2   | c1 | c2   | c1 | c2   |
+----+------+----+------+----+------+
|  1 | a1   | NULL | NULL | NULL | NULL |
+----+------+----+------+----+------+
EXPLAIN select /*+no_rewrite, use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 left join tt3 on tt1.c1 = tt3.c1 where tt1.c1 = 1;
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |MERGE OUTER JOIN |    |1        |7   |
|1 | MERGE OUTER JOIN|    |1        |5   |
|2 |  TABLE GET      |tt1 |1        |3   |
|3 |  TABLE SCAN     |tt2 |2        |2   |
|4 | TABLE SCAN      |tt3 |2        |2   |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2], [tt3.c1], [tt3.c2]), filter(nil), rowset=256, 
      equal_conds([tt1.c1 = tt3.c1]), other_conds(nil)
  1 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2]), filter(nil), rowset=256, 
      equal_conds([tt1.c1 = tt2.c1]), other_conds(nil)
  2 - output([tt1.c1], [tt1.c2]), filter(nil), rowset=256, 
      access([tt1.c1], [tt1.c2]), partitions(p0)
  3 - output([tt2.c1], [tt2.c2]), filter(nil), rowset=256, 
      access([tt2.c1], [tt2.c2]), partitions(p0)
  4 - output([tt3.c1], [tt3.c2]), filter(nil), rowset=256, 
      access([tt3.c1], [tt3.c2]), partitions(p0)

select /*+no_rewrite, use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 left join tt3 on tt1.c1 = tt3.c1 where tt1.c1 = 1;
+----+------+----+------+----+------+
| c1 | c2   | c1 | c2   | c1 | c2   |
+----+------+----+------+----+------+
|  1 | a1   | NULL | NULL | NULL | NULL |
+----+------+----+------+----+------+

## tt1 left join tt2 left join tt3
EXPLAIN select /*+use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 left join tt3 on tt2.c1 = tt3.c1 where tt1.c1 = 1;
Query Plan
=========================================================
|ID|OPERATOR                        |NAME|EST. ROWS|COST|
---------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN CARTESIAN|    |1        |8   |
|1 | TABLE GET                      |tt1 |1        |3   |
|2 | MERGE OUTER JOIN               |    |1        |5   |
|3 |  TABLE GET                     |tt2 |1        |3   |
|4 |  TABLE SCAN                    |tt3 |2        |2   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2], [tt3.c1], [tt3.c2]), filter(nil), rowset=256, 
      conds(nil), nl_params_(nil)
  1 - output([tt1.c1], [tt1.c2]), filter(nil), rowset=256, 
      access([tt1.c1], [tt1.c2]), partitions(p0)
  2 - output([tt2.c1], [tt2.c2], [tt3.c1], [tt3.c2]), filter(nil), rowset=256, 
      equal_conds([tt2.c1 = tt3.c1]), other_conds(nil)
  3 - output([tt2.c1], [tt2.c2]), filter(nil), rowset=256, 
      access([tt2.c1], [tt2.c2]), partitions(p0)
  4 - output([tt3.c1], [tt3.c2]), filter(nil), rowset=256, 
      access([tt3.c1], [tt3.c2]), partitions(p0)

select /*+use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 left join tt3 on tt2.c1 = tt3.c1 where tt1.c1 = 1;
+----+------+----+------+----+------+
| c1 | c2   | c1 | c2   | c1 | c2   |
+----+------+----+------+----+------+
|  1 | a1   | NULL | NULL | NULL | NULL |
+----+------+----+------+----+------+
EXPLAIN select /*+no_rewrite, use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 left join tt3 on tt2.c1 = tt3.c1 where tt1.c1 = 1;
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |MERGE OUTER JOIN |    |1        |7   |
|1 | MERGE OUTER JOIN|    |1        |5   |
|2 |  TABLE GET      |tt1 |1        |3   |
|3 |  TABLE SCAN     |tt2 |2        |2   |
|4 | TABLE SCAN      |tt3 |2        |2   |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2], [tt3.c1], [tt3.c2]), filter(nil), rowset=256, 
      equal_conds([tt2.c1 = tt3.c1]), other_conds(nil)
  1 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2]), filter(nil), rowset=256, 
      equal_conds([tt1.c1 = tt2.c1]), other_conds(nil)
  2 - output([tt1.c1], [tt1.c2]), filter(nil), rowset=256, 
      access([tt1.c1], [tt1.c2]), partitions(p0)
  3 - output([tt2.c1], [tt2.c2]), filter(nil), rowset=256, 
      access([tt2.c1], [tt2.c2]), partitions(p0)
  4 - output([tt3.c1], [tt3.c2]), filter(nil), rowset=256, 
      access([tt3.c1], [tt3.c2]), partitions(p0)

select /*+no_rewrite, use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 left join tt3 on tt2.c1 = tt3.c1 where tt1.c1 = 1;
+----+------+----+------+----+------+
| c1 | c2   | c1 | c2   | c1 | c2   |
+----+------+----+------+----+------+
|  1 | a1   | NULL | NULL | NULL | NULL |
+----+------+----+------+----+------+

## tt3 left join (tt1 left join tt2)
EXPLAIN select /*+use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 right join tt3 on tt1.c1 = tt3.c1 where tt1.c1 = 1;
Query Plan
=========================================================
|ID|OPERATOR                        |NAME|EST. ROWS|COST|
---------------------------------------------------------
|0 |NESTED-LOOP OUTER JOIN CARTESIAN|    |1        |9   |
|1 | NESTED-LOOP JOIN CARTESIAN     |    |1        |6   |
|2 |  TABLE GET                     |tt3 |1        |3   |
|3 |  TABLE GET                     |tt1 |1        |3   |
|4 | TABLE GET                      |tt2 |1        |3   |
=========================================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2], [tt3.c1], [tt3.c2]), filter(nil), rowset=256, 
      conds(nil), nl_params_(nil)
  1 - output([tt1.c1], [tt1.c2], [tt3.c1], [tt3.c2]), filter(nil), rowset=256, 
      conds(nil), nl_params_(nil)
  2 - output([tt3.c1], [tt3.c2]), filter(nil), rowset=256, 
      access([tt3.c1], [tt3.c2]), partitions(p0)
  3 - output([tt1.c1], [tt1.c2]), filter(nil), rowset=256, 
      access([tt1.c1], [tt1.c2]), partitions(p0)
  4 - output([tt2.c1], [tt2.c2]), filter(nil), rowset=256, 
      access([tt2.c1], [tt2.c2]), partitions(p0)

select /*+use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 right join tt3 on tt1.c1 = tt3.c1 where tt1.c1 = 1;
+----+------+----+------+----+------+
| c1 | c2   | c1 | c2   | c1 | c2   |
+----+------+----+------+----+------+
+----+------+----+------+----+------+
EXPLAIN select /*+no_rewrite, use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 right join tt3 on tt1.c1 = tt3.c1 where tt1.c1 = 1;
Query Plan
==========================================
|ID|OPERATOR         |NAME|EST. ROWS|COST|
------------------------------------------
|0 |MERGE OUTER JOIN |    |1        |6   |
|1 | TABLE SCAN      |tt3 |2        |2   |
|2 | MERGE OUTER JOIN|    |3        |4   |
|3 |  TABLE SCAN     |tt1 |3        |2   |
|4 |  TABLE SCAN     |tt2 |2        |2   |
==========================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2], [tt3.c1], [tt3.c2]), filter([tt1.c1 = 1]), rowset=256, 
      equal_conds([tt1.c1 = tt3.c1]), other_conds(nil)
  1 - output([tt3.c1], [tt3.c2]), filter(nil), rowset=256, 
      access([tt3.c1], [tt3.c2]), partitions(p0)
  2 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2]), filter(nil), rowset=256, 
      equal_conds([tt1.c1 = tt2.c1]), other_conds(nil)
  3 - output([tt1.c1], [tt1.c2]), filter(nil), rowset=256, 
      access([tt1.c1], [tt1.c2]), partitions(p0)
  4 - output([tt2.c1], [tt2.c2]), filter(nil), rowset=256, 
      access([tt2.c1], [tt2.c2]), partitions(p0)

select /*+no_rewrite, use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 right join tt3 on tt1.c1 = tt3.c1 where tt1.c1 = 1;
+----+------+----+------+----+------+
| c1 | c2   | c1 | c2   | c1 | c2   |
+----+------+----+------+----+------+
+----+------+----+------+----+------+

## tt3 left join (tt1 left join tt2)
EXPLAIN select /*+use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 right join tt3 on tt2.c1 = tt3.c1 where tt1.c1 = 1;
Query Plan
====================================================
|ID|OPERATOR                   |NAME|EST. ROWS|COST|
----------------------------------------------------
|0 |NESTED-LOOP JOIN CARTESIAN |    |1        |9   |
|1 | TABLE GET                 |tt2 |1        |3   |
|2 | NESTED-LOOP JOIN CARTESIAN|    |1        |6   |
|3 |  TABLE GET                |tt3 |1        |3   |
|4 |  TABLE GET                |tt1 |1        |3   |
====================================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2], [tt3.c1], [tt3.c2]), filter(nil), rowset=256, 
      conds(nil), nl_params_(nil)
  1 - output([tt2.c1], [tt2.c2]), filter(nil), rowset=256, 
      access([tt2.c1], [tt2.c2]), partitions(p0)
  2 - output([tt1.c1], [tt1.c2], [tt3.c1], [tt3.c2]), filter(nil), rowset=256, 
      conds(nil), nl_params_(nil)
  3 - output([tt3.c1], [tt3.c2]), filter(nil), rowset=256, 
      access([tt3.c1], [tt3.c2]), partitions(p0)
  4 - output([tt1.c1], [tt1.c2]), filter(nil), rowset=256, 
      access([tt1.c1], [tt1.c2]), partitions(p0)

select /*+use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 right join tt3 on tt2.c1 = tt3.c1 where tt1.c1 = 1;
+----+------+----+------+----+------+
| c1 | c2   | c1 | c2   | c1 | c2   |
+----+------+----+------+----+------+
+----+------+----+------+----+------+
EXPLAIN select /*+no_rewrite, use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 right join tt3 on tt2.c1 = tt3.c1 where tt1.c1 = 1;
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |HASH OUTER JOIN        |    |1        |7   |
|1 | TABLE SCAN            |tt3 |2        |2   |
|2 | MERGE RIGHT OUTER JOIN|    |3        |4   |
|3 |  TABLE SCAN           |tt2 |2        |2   |
|4 |  TABLE SCAN           |tt1 |3        |2   |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2], [tt3.c1], [tt3.c2]), filter([tt1.c1 = 1]), rowset=256, 
      equal_conds([tt2.c1 = tt3.c1]), other_conds(nil)
  1 - output([tt3.c1], [tt3.c2]), filter(nil), rowset=256, 
      access([tt3.c1], [tt3.c2]), partitions(p0)
  2 - output([tt1.c1], [tt1.c2], [tt2.c1], [tt2.c2]), filter(nil), rowset=256, 
      equal_conds([tt1.c1 = tt2.c1]), other_conds(nil)
  3 - output([tt2.c1], [tt2.c2]), filter(nil), rowset=256, 
      access([tt2.c1], [tt2.c2]), partitions(p0)
  4 - output([tt1.c1], [tt1.c2]), filter(nil), rowset=256, 
      access([tt1.c1], [tt1.c2]), partitions(p0)

select /*+no_rewrite, use_merge(tt1 tt2 tt3)*/ * from tt1 left join tt2 on tt1.c1 = tt2.c1 right join tt3 on tt2.c1 = tt3.c1 where tt1.c1 = 1;
+----+------+----+------+----+------+
| c1 | c2   | c1 | c2   | c1 | c2   |
+----+------+----+------+----+------+
+----+------+----+------+----+------+

## online case
drop table if exists cghldinf, puzdjypf, pujydypf;
CREATE TABLE `cghldinf` (
    `HLDGDDM` char(10) NOT NULL,
    `HLDZXWH` char(5)  NOT NULL,
    `HLDTGDM` decimal(9, 0) NOT NULL,
    `HLDKMLB` char(2) NOT NULL,
    PRIMARY KEY (`HLDTGDM`, `HLDGDDM`),
    KEY `HLDINDEX` (`HLDKMLB`) LOCAL
    ) partition by key (hldgddm) partitions 13;

CREATE TABLE `puzdjypf` (
    `PZJZQZH` char(20) NOT NULL,
    `PZJZDJYDY` char(6) NOT NULL,
    `PZJSXRQ` decimal(8,0) NOT NULL,
    PRIMARY KEY (`PZJZQZH`)
    ) partition by key (pzjzqzh) partitions 13;

CREATE TABLE `pujydypf` (
    `PJYSCDM` char(2) NOT NULL,
    `PJYJYDY` char(6) NOT NULL,
    `PJYJYDYLB` char(3) NOT NULL,
    `PJYQSBH` char(8) NOT NULL
    ) partition by key (pjyjydy) partitions 2;

EXPLAIN select /*+use_merge(t1 t2), leading(t1 t2 t3)*/ t1.hldgddm, t2.pzjzqzh, t2.pzjzdjydy, t3.pjyjydy, t3.pjyscdm from cghldinf t1 left join puzdjypf t2 on t2.pzjzqzh = t1.hldgddm left join pujydypf t3 on t2.pzjzdjydy = t3.pjyjydy and t3.pjyscdm = '01' where hldgddm = 'A100013208';
Query Plan
==================================================================
|ID|OPERATOR                             |NAME    |EST. ROWS|COST|
------------------------------------------------------------------
|0 |PX COORDINATOR                       |        |1        |13  |
|1 | EXCHANGE OUT DISTR                  |:EX10001|1        |12  |
|2 |  HASH OUTER JOIN                    |        |1        |11  |
|3 |   EXCHANGE IN DISTR                 |        |1        |6   |
|4 |    EXCHANGE OUT DISTR (PKEY)        |:EX10000|1        |6   |
|5 |     NESTED-LOOP OUTER JOIN CARTESIAN|        |1        |5   |
|6 |      TABLE SCAN                     |t1      |1        |2   |
|7 |      MATERIAL                       |        |1        |3   |
|8 |       TABLE GET                     |t2      |1        |3   |
|9 |   PX PARTITION ITERATOR             |        |1        |4   |
|10|    TABLE SCAN                       |t3      |1        |4   |
==================================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.HLDGDDM, t2.PZJZQZH, t2.PZJZDJYDY, t3.PJYJYDY, t3.PJYSCDM)]), filter(nil), rowset=256
  1 - output([INTERNAL_FUNCTION(t1.HLDGDDM, t2.PZJZQZH, t2.PZJZDJYDY, t3.PJYJYDY, t3.PJYSCDM)]), filter(nil), rowset=256, dop=1
  2 - output([t2.PZJZDJYDY], [t3.PJYJYDY], [t1.HLDGDDM], [t2.PZJZQZH], [t3.PJYSCDM]), filter(nil), rowset=256, 
      equal_conds([t2.PZJZDJYDY = t3.PJYJYDY]), other_conds(nil)
  3 - output([t2.PZJZDJYDY], [t1.HLDGDDM], [t2.PZJZQZH]), filter(nil), rowset=256
  4 - (#keys=1, [t2.PZJZDJYDY]), output([t2.PZJZDJYDY], [t1.HLDGDDM], [t2.PZJZQZH]), filter(nil), rowset=256, is_single, dop=1
  5 - output([t2.PZJZDJYDY], [t1.HLDGDDM], [t2.PZJZQZH]), filter(nil), rowset=256, 
      conds(nil), nl_params_(nil)
  6 - output([t1.HLDGDDM]), filter([t1.HLDGDDM = 'A100013208']), rowset=256, 
      access([t1.HLDGDDM]), partitions(p5)
  7 - output([t2.PZJZDJYDY], [t2.PZJZQZH]), filter(nil), rowset=256
  8 - output([t2.PZJZQZH], [t2.PZJZDJYDY]), filter(nil), rowset=256, 
      access([t2.PZJZQZH], [t2.PZJZDJYDY]), partitions(p5)
  9 - output([t3.PJYJYDY], [t3.PJYSCDM]), filter(nil), rowset=256
  10 - output([t3.PJYJYDY], [t3.PJYSCDM]), filter([t3.PJYSCDM = '01']), rowset=256, 
      access([t3.PJYJYDY], [t3.PJYSCDM]), partitions(p[0-1])

select /*+use_merge(t1 t2), leading(t1 t2 t3)*/ t1.hldgddm, t2.pzjzqzh, t2.pzjzdjydy, t3.pjyjydy, t3.pjyscdm from cghldinf t1 left join puzdjypf t2 on t2.pzjzqzh = t1.hldgddm left join pujydypf t3 on t2.pzjzdjydy = t3.pjyjydy and t3.pjyscdm = '01' where hldgddm = 'A100013208';
+------------+------------+-----------+---------+---------+
| hldgddm    | pzjzqzh    | pzjzdjydy | pjyjydy | pjyscdm |
+------------+------------+-----------+---------+---------+
| A100013208 | A100013208 | 20605     | NULL    | NULL    |
| A100013208 | A100013208 | 20605     | NULL    | NULL    |
+------------+------------+-----------+---------+---------+
EXPLAIN select /*+no_rewrite, use_merge(t1 t2), leading(t1 t2 t3)*/ t1.hldgddm, t2.pzjzqzh, t2.pzjzdjydy, t3.pjyjydy, t3.pjyscdm from cghldinf t1 left join puzdjypf t2 on t2.pzjzqzh = t1.hldgddm left join pujydypf t3 on t2.pzjzdjydy = t3.pjyjydy and t3.pjyscdm = '01' where hldgddm = 'A100013208';
Query Plan
=============================================================
|ID|OPERATOR                        |NAME    |EST. ROWS|COST|
-------------------------------------------------------------
|0 |PX COORDINATOR                  |        |1        |33  |
|1 | EXCHANGE OUT DISTR             |:EX10002|1        |32  |
|2 |  HASH OUTER JOIN               |        |1        |31  |
|3 |   EXCHANGE IN DISTR            |        |1        |27  |
|4 |    EXCHANGE OUT DISTR (PKEY)   |:EX10001|1        |26  |
|5 |     MERGE OUTER JOIN           |        |1        |25  |
|6 |      EXCHANGE IN DISTR         |        |1        |3   |
|7 |       EXCHANGE OUT DISTR (PKEY)|:EX10000|1        |3   |
|8 |        TABLE SCAN              |t1      |1        |2   |
|9 |      SORT                      |        |1        |23  |
|10|       PX PARTITION ITERATOR    |        |1        |22  |
|11|        TABLE SCAN              |t2      |1        |22  |
|12|   PX PARTITION ITERATOR        |        |1        |4   |
|13|    TABLE SCAN                  |t3      |1        |4   |
=============================================================

Outputs & filters: 
-------------------------------------
  0 - output([INTERNAL_FUNCTION(t1.HLDGDDM, t2.PZJZQZH, t2.PZJZDJYDY, t3.PJYJYDY, t3.PJYSCDM)]), filter(nil), rowset=256
  1 - output([INTERNAL_FUNCTION(t1.HLDGDDM, t2.PZJZQZH, t2.PZJZDJYDY, t3.PJYJYDY, t3.PJYSCDM)]), filter(nil), rowset=256, dop=1
  2 - output([t2.PZJZDJYDY], [t3.PJYJYDY], [t2.PZJZQZH], [t1.HLDGDDM], [t3.PJYSCDM]), filter(nil), rowset=256, 
      equal_conds([t2.PZJZDJYDY = t3.PJYJYDY]), other_conds(nil)
  3 - output([t2.PZJZDJYDY], [t2.PZJZQZH], [t1.HLDGDDM]), filter(nil), rowset=256
  4 - (#keys=1, [t2.PZJZDJYDY]), output([t2.PZJZDJYDY], [t2.PZJZQZH], [t1.HLDGDDM]), filter(nil), rowset=256, dop=1
  5 - output([t2.PZJZDJYDY], [t2.PZJZQZH], [t1.HLDGDDM]), filter(nil), rowset=256, 
      equal_conds([t2.PZJZQZH = t1.HLDGDDM]), other_conds(nil)
  6 - output([t1.HLDGDDM]), filter(nil), rowset=256
  7 - (#keys=1, [t1.HLDGDDM]), output([t1.HLDGDDM]), filter(nil), rowset=256, is_single, dop=1
  8 - output([t1.HLDGDDM]), filter([t1.HLDGDDM = 'A100013208']), rowset=256, 
      access([t1.HLDGDDM]), partitions(p5)
  9 - output([t2.PZJZDJYDY], [t2.PZJZQZH]), filter(nil), rowset=256, sort_keys([t2.PZJZQZH, ASC]), local merge sort
  10 - output([t2.PZJZQZH], [t2.PZJZDJYDY]), filter(nil), rowset=256
  11 - output([t2.PZJZQZH], [t2.PZJZDJYDY]), filter(nil), rowset=256, 
      access([t2.PZJZQZH], [t2.PZJZDJYDY]), partitions(p[0-12])
  12 - output([t3.PJYJYDY], [t3.PJYSCDM]), filter(nil), rowset=256
  13 - output([t3.PJYJYDY], [t3.PJYSCDM]), filter([t3.PJYSCDM = '01']), rowset=256, 
      access([t3.PJYJYDY], [t3.PJYSCDM]), partitions(p[0-1])

select /*+no_rewrite, use_merge(t1 t2), leading(t1 t2 t3)*/ t1.hldgddm, t2.pzjzqzh, t2.pzjzdjydy, t3.pjyjydy, t3.pjyscdm from cghldinf t1 left join puzdjypf t2 on t2.pzjzqzh = t1.hldgddm left join pujydypf t3 on t2.pzjzdjydy = t3.pjyjydy and t3.pjyscdm = '01' where hldgddm = 'A100013208';
+------------+------------+-----------+---------+---------+
| hldgddm    | pzjzqzh    | pzjzdjydy | pjyjydy | pjyscdm |
+------------+------------+-----------+---------+---------+
| A100013208 | A100013208 | 20605     | NULL    | NULL    |
| A100013208 | A100013208 | 20605     | NULL    | NULL    |
+------------+------------+-----------+---------+---------+

## bug: https://work.aone.alibaba-inc.com/issue/32926523
drop table if exists t1, t2;
create table t1 (c1 int, c2 int, primary key(c1));
create table t2 (c1 int, c2 int, primary key(c2));

explain extended_noaddr select count(*) from t1 A, t2 B where A.c1 >= 5630905 and A.c1 < 5631105 and A.c1 = B.c2 and A.c2 = B.c2;
Query Plan
================================================
|ID|OPERATOR               |NAME|EST. ROWS|COST|
------------------------------------------------
|0 |SCALAR GROUP BY        |    |1        |4   |
|1 | NESTED-LOOP JOIN      |    |1        |4   |
|2 |  TABLE SCAN           |A   |1        |2   |
|3 |  DISTRIBUTED TABLE GET|B   |1        |16  |
================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(*)]), filter(nil), rowset=256, 
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output(nil), filter(nil), rowset=256, 
      conds(nil), nl_params_([A.c1]), batch_join=true
  2 - output([A.c1]), filter([A.c2 < 5631105], [A.c1 = A.c2]), rowset=256, 
      access([A.c1], [A.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([A.c1]), range[5630905 ; 5631105), 
      range_cond([A.c1 >= 5630905], [A.c1 < 5631105])
  3 - output(nil), filter(nil), rowset=256, 
      access([GROUP_ID]), partitions(p0), 
      is_index_back=false, 
      range_key([B.c2]), range(MIN ; MAX), 
      range_cond([? = B.c2])


drop table t1, t2;
create table t1 (c1 int, c2 int, index (c1));
create table t2 (c1 int, c2 int, index (c2));

explain extended_noaddr select count(*) from t1 A, t2 B where A.c1 >= 5630905 and A.c1 < 5631105 and A.c1 = B.c2 and A.c2 = B.c2;
Query Plan
==================================================
|ID|OPERATOR                |NAME |EST. ROWS|COST|
--------------------------------------------------
|0 |SCALAR GROUP BY         |     |1        |4   |
|1 | NESTED-LOOP JOIN       |     |1        |4   |
|2 |  TABLE SCAN            |A    |1        |2   |
|3 |  DISTRIBUTED TABLE SCAN|B(c2)|1        |16  |
==================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT(*)]), filter(nil), rowset=256, 
      group(nil), agg_func([T_FUN_COUNT(*)])
  1 - output(nil), filter(nil), rowset=256, 
      conds(nil), nl_params_([A.c1]), batch_join=true
  2 - output([A.c1]), filter([A.c1 >= 5630905], [A.c1 < 5631105], [A.c2 < 5631105], [A.c1 = A.c2]), rowset=256, 
      access([A.c1], [A.c2]), partitions(p0), 
      is_index_back=false, filter_before_indexback[false,false,false,false], 
      range_key([A.__pk_increment]), range(MIN ; MAX)always true
  3 - output(nil), filter(nil), rowset=256, 
      access([GROUP_ID]), partitions(p0), 
      is_index_back=false, 
      range_key([B.c2], [B.__pk_increment]), range(MIN ; MAX), 
      range_cond([? = B.c2])


drop table t1, t2;
create table t1 (c1 int, c2 int) partition by hash(c1) partitions 4;
create table t2 (c1 int, c2 int) partition by hash(c2) partitions 4;

explain extended_noaddr select count(*) from t1 A, t2 B where A.c1 >= 5630905 and A.c1 < 5631105 and A.c1 = B.c2 and A.c2 = B.c2;
Query Plan
======================================================
|ID|OPERATOR                 |NAME    |EST. ROWS|COST|
------------------------------------------------------
|0 |SCALAR GROUP BY          |        |1        |15  |
|1 | PX COORDINATOR          |        |1        |15  |
|2 |  EXCHANGE OUT DISTR     |:EX10000|1        |14  |
|3 |   MERGE GROUP BY        |        |1        |14  |
|4 |    PX PARTITION ITERATOR|        |1        |14  |
|5 |     HASH JOIN           |        |1        |14  |
|6 |      TABLE SCAN         |A       |1        |7   |
|7 |      TABLE SCAN         |B       |1        |7   |
======================================================

Outputs & filters: 
-------------------------------------
  0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), rowset=256, 
      group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
  1 - output([T_FUN_COUNT(*)]), filter(nil), rowset=256
  2 - output([T_FUN_COUNT(*)]), filter(nil), rowset=256, dop=1
  3 - output([T_FUN_COUNT(*)]), filter(nil), rowset=256, 
      group(nil), agg_func([T_FUN_COUNT(*)])
  4 - output(nil), filter(nil), rowset=256, 
      partition wise, force partition granule.
  5 - output(nil), filter(nil), rowset=256, 
      equal_conds([A.c1 = B.c2]), other_conds(nil)
  6 - output([A.c1]), filter([A.c1 >= 5630905], [A.c1 < 5631105], [A.c2 < 5631105], [A.c1 = A.c2]), rowset=256, 
      access([A.c1], [A.c2]), partitions(p[0-3]), 
      is_index_back=false, filter_before_indexback[false,false,false,false], 
      range_key([A.__pk_increment]), range(MIN ; MAX)always true
  7 - output([B.c2]), filter([B.c2 < 5631105], [B.c2 >= 5630905]), rowset=256, 
      access([B.c2]), partitions(p[0-3]), 
      is_index_back=false, filter_before_indexback[false,false], 
      range_key([B.__pk_increment]), range(MIN ; MAX)always true



drop table if exists t1, t2, t3;
drop table if exists tt1, tt2, tt3;
drop table if exists cghldinf, puzdjypf, pujydypf;
USE DB_PREDICATE_DEDUCE;
drop database DB_PREDICATE_DEDUCE;
